#!/usr/bin/env python3

"""
Take in a FITS image generated by wsclean and appened a second header/data unit
that contains the primary element (dipole) beam correction.
"""

import os
import sys
import numpy as np

from astropy.io import fits as astrofits
from astropy.wcs import WCS as AstroWCS
from astropy.coordinates import EarthLocation, AltAz

from lsl.common.paths import DATA as dataPath
from lsl.imaging.utils import ImgWPlus
from lsl.common.stations import lwa1


LWA1 = EarthLocation(str(lwa1.lon), str(lwa1.lat), height=lwa1.elev)


def load_beam_pattern(frequency, pol, include_empirical=True):
    if pol not in ('XX', 'YY'):
        raise ValueError(f"Unknown polarization '{pol}'")
        
    beamDict = np.load(os.path.join(dataPath, 'lwa1-dipole-emp.npz'))
    
    beamCoeff = beamDict['fit'+pol[0]]
    alphaE = np.polyval(beamCoeff[0,0,:], frequency)
    betaE =  np.polyval(beamCoeff[0,1,:], frequency)
    gammaE = np.polyval(beamCoeff[0,2,:], frequency)
    deltaE = np.polyval(beamCoeff[0,3,:], frequency)
    alphaH = np.polyval(beamCoeff[1,0,:], frequency)
    betaH =  np.polyval(beamCoeff[1,1,:], frequency)
    gammaH = np.polyval(beamCoeff[1,2,:], frequency)
    deltaH = np.polyval(beamCoeff[1,3,:], frequency)
    
    if include_empirical:
        corrDict = np.load(os.path.join(dataPath, 'lwa1-dipole-cor.npz'))
        cFreqs = corrDict['freqs']
        cAlts  = corrDict['alts']
        if corrDict['degrees'].item():
            cAlts *= np.pi / 180.0
        cCorrs = corrDict['corrs']
        corrDict.close()
        
        if frequency/1e6 < cFreqs.min() or frequency/1e6 > cFreqs.max():
            print("WARNING: Input frequency of %.3f MHz is out of range, skipping empirical correction" % (frequency/1e6,))
            corrFnc = None
        else:
            fCors = cAlts*0.0
            for j in range(fCors.size):
                ffnc = interp1d(cFreqs, cCorrs[:,j], bounds_error=False)
                fCors[j] = ffnc(frequency/1e6)
            corrFnc = interp1d(cAlts, fCors, bounds_error=False)
            
    else:
        corrFnc = None
        
    def compute_beam_pattern(az, alt, corr=corrFnc):
        zaR = np.pi/2 - alt*np.pi / 180.0 
        azR = az*np.pi / 180.0
        
        c = 1.0
        if corrFnc is not None:
            c = corrFnc(alt*np.pi / 180.0)
            c = np.where(np.isfinite(c), c, 1.0)
            
        pE = (1-(2*zaR/np.pi)**alphaE)*np.cos(zaR)**betaE + gammaE*(2*zaR/np.pi)*np.cos(zaR)**deltaE
        pH = (1-(2*zaR/np.pi)**alphaH)*np.cos(zaR)**betaH + gammaH*(2*zaR/np.pi)*np.cos(zaR)**deltaH
        return c*np.sqrt((pE*np.cos(azR))**2 + (pH*np.sin(azR))**2)
        
    return lambda x, y: compute_beam_pattern(x, y)


def main(args):
    cache = {}
    for filename in args:
        # Figure out which polarization we are dealing with based on the filename
        shortname = os.path.basename(filename)
        pol = 'XX' if shortname.find('XX') != -1 else 'YY'
        
        # Open the file and load in the header to get the center frequency
        hdu = astrofits.open(filename, mode='update')
        hdr = hdu[0].header
        freq = hdr['CRVAL3']
        
        # Extract the WCS so that we can transform pixel -> ra/dec -> az/alt
        wcs = AstroWCS(hdr)
        c = np.arange(0, hdr['NAXIS1'])
        pxx, pxy = np.meshgrid(c, c)
        eq, _, _ = wcs.pixel_to_world(pxx, pxy, 0, 0)
        aa_system = AltAz(location=LWA1, obstime=hdr['DATE-OBS'])
        aa = eq.transform_to(aa_system)
        
        # Load in the relevant beam pattern generation function
        cname = (freq, pol, True)
        try:
            func = cache[cname]
        except KeyError:
            func = load_beam_pattern(*cname)
            cache[cname] = func
            
        # Compute the beam
        beam = func(aa.az.to('deg').value, aa.alt.to('deg').value)
        beam.shape = (1,1)+beam.shape
        
        # Save to the beam to a new exention and write everything to disk
        beam_hdu = astrofits.ImageHDU(beam, header=hdr)
        try:
            hdu[1] = beam_hdu
        except IndexError:
            hdu.append(beam_hdu)
        hdu[0].header['BTYPE'] = 'Weight'
        hdu[0].header['HISTORY'] = f"Beam pattern correction for '{str(cname)}'"
        hdu.flush()
        hdu.close()


if __name__ == '__main__':
    main(sys.argv[1:])
